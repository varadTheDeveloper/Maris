
# Curve25519 has two representations:

Representation	Used for	Name
Montgomery form	Diffieâ€“Hellman	X25519
Twisted Edwards form	Signatures	Ed25519
# X25519 (Diffieâ€“Hellman side)

Used for:
X3DH
Double Ratchet DH ratchet
Ephemeral keys
Prekeys
Operation:
shared = scalar Ã— point

Properties:
Constant-time
Safe clamping
Simple API
In libsodium:
crypto_scalarmult()
crypto_kx_keypair()
# Ed25519 (Signature side)

Used for:
Identity keys
Signing signed-prekeys

Authenticating users/devices
Properties:
Very fast signatures
Deterministic signin
Strong security proofs

In libsodium:
crypto_sign_keypair()
crypto_sign_detached()
Curve25519
â”œâ”€â”€ X25519 â†’ Diffieâ€“Hellman (shared secrets)
â””â”€â”€ Ed25519 â†’ Signatures (identity & auth)

 # Curve25519 has two representations:
Purpose	    Form
Signatures	Edwards (Ed25519)
DH	        Montgomery (X25519) 
  # imp:
IDENTITY KEY      â†’ once in lifetime
SIGNED PREKEY     â†’ rotate sometimes
ONE-TIME PREKEY   â†’ use once
EPHEMERAL KEY     â†’ per session
MESSAGE KEYS      â†’ per message (from ratchet) 
# imp 2:
HOW LONG do keys live? (VERY IMPORTANT)
Key	Who	Lifetime 
Identity key (I)	    Alice/Bob	  ğŸ”’ Long-term (months/years)
Signed prekey (S) 	  Bob	        â± Medium-term (days/weeks)
One-time prekey (O) 	Bob	        ğŸ”¥ ONE TIME ONLY
Ephemeral key (E_A) 	Alice	      âŒ Deleted after X3DH
DH ratchet keys	      Both	     ğŸ”„ Rotated many times
Message keys (MK)	    Both	     ğŸ—‘ Deleted immediately

  # 1 : Identity Key (IK) â€” generate ONCE, store forever
Generated once when user registers / installs app
Type: Ed25519 (signing key)
purpose:Proves â€œthis is really Aliceâ€ Signs the Signed Prekey
Stored:Private key â†’ encrypted on device
Public key â†’ server (never changes)
âœ… Never rotate
âœ… Never per message
âœ… Lifetime key
â“ Do we regenerate identity keys? âŒ No (unless user resets account)



# 2 : Signed Prekey (ROTATES, not lifetime)
What it is Medium-term key Generated after identity Signed using identity private key
Where it lives Private â†’ on device .Public + signature â†’ uploaded to server
How often Rotated every days / weeks NOT per message NOT lifetime
Why Allows offline users to receive messages Prevents MITM (because itâ€™s signed by identity)
ğŸ“Œ Think of it as: temporary public contact number, verified by passport
â“ Do we regenerate signed prekeys? âœ… Yes (periodically)


# 3: OneTimePrekeys
A one-time prekey is a throw-away public key
that is used once, then deleted forever.
1: we have to stote privaet key at device an1 store public key at server
2: delete public after oen time use and fetch next from client
3:after use deletes that private key forever from both sides 



# 4 : Ephemeral Key (VERY SHORT-TERM) or session key 
Generated by the sender
Used in X3DH
Used for starting ONE session
Deleted after handshake
NOT used forever
NOT reused
ğŸ‘‰ Think: â€œHandshake secretâ€
# WHEN EPHEMERAL KEY IS DELETED
On sender side:
Delete E_A private after X3DH
Never reuse it
Keep only derived session keys (RK, CK)

On Recevier side:
never stores E_A private (he doesnâ€™t have it)
uses E_A public once
After session established â†’ discard
X3DH (VERY IMPORTANT)

# X3DH,
# BOTH Alice and Bob already computed the SAME values:
RK  (Root Key)   âœ… same on both sides
CK  (Chain Key)  âœ… same on both sides
ğŸ‘‰ They NEVER send RK or CK to each other
ğŸ‘‰ They are the same because DH math guarantees it
this is where people get confused â€” so remember this:
ğŸ”’ Keys are NEVER sent. Only PUBLIC keys are sent.

# Double Ratchet
// has TWO ratchets:
ğŸ” Symmetric ratchet â†’ per-message keys
ğŸ”„ DH ratchet â†’ per-session reset
# Symmetric ratchet :CK into two chains
 # Alice side
CK_sending   = HKDF(CK, "send")
CK_receiving = HKDF(CK, "recv")

# Bob side (FLIPPED)
CK_receiving = HKDF(CK, "send")  â† same bytes as Alice send
CK_sending   = HKDF(CK, "recv")  â† same bytes as Alice recv

ğŸ‘‰ This is how both sides stay in sync WITHOUT sending keys
# Alice side
CK_sending   = HKDF(CK, "send")
CK_receiving = HKDF(CK, "recv")

Bob side (FLIPPED)
CK_receiving = HKDF(CK, "send")  â† same bytes as Alice send
CK_sending   = HKDF(CK, "recv")  â† same bytes as Alice recv


ğŸ‘‰ This is how both sides stay in sync WITHOUT sending keys
# Symmetric Ratchet
FIRST MESSAGE (Symmetric Ratchet ONLY)
Now Alice wants to send message #1.
 # Alice derives Message Key (MKâ‚)
MK1 = HKDF(CK_sending, "mk")
CK_sending = HKDF(CK_sending, "ck_next")
Thatâ€™s it.
MK1 â†’ encrypts message
CK_sending â†’ moves forward
ğŸ‘‰ Alice forgets MK1 forever after encrypting

4ï¸âƒ£ Alice sends message to Bob
She sends ONLY this:
{
  ciphertext,
  nonce
}
âŒ NO keys
âŒ NO CK
âŒ NO RK

5ï¸âƒ£ Bob receives and decrypts (SAME STEPS)
Bob knows this is message #1 from Alice, so he uses his receiving chain:
MK1 = HKDF(CK_receiving, "mk")
CK_receiving = HKDF(CK_receiving, "ck_next")

ğŸ‘‰ This MK1 is IDENTICAL to Aliceâ€™s MK1
Why?Because:
CK was same
HKDF inputs were same
Order is same
Now Bob decrypts successfully.

6ï¸âƒ£ SECOND MESSAGE (still symmetric ratchet)

Alice sends message #2:

MK2 = HKDF(CK_sending, "mk")
CK_sending = HKDF(CK_sending, "ck_next")


Bob receives:

MK2 = HKDF(CK_receiving, "mk")
CK_receiving = HKDF(CK_receiving, "ck_next")


ğŸ” This continues for many messages.

7ï¸âƒ£ IMPORTANT: Where is DH ratchet?

ğŸ‘‰ NOT YET

DH ratchet happens ONLY when the OTHER SIDE replies
OR when someone sends a new DH public key in header

Right now:
Only symmetric ratchet is active
No DH key sent yet

8ï¸âƒ£ VERY SIMPLE MENTAL MODEL (REMEMBER THIS)
After X3DH:
RK â”€â”€â”
     â””â”€> CK â”€â”€> CK_send â”€â”€> MK1 â”€â”€> MK2 â”€â”€> MK3

Bob mirrors it:
CK_recv â”€â”€> MK1 â”€â”€> MK2 â”€â”€> MK3
NO COMMUNICATION about keys.

# Alice side
stateAlice = initDoubleRatchet(RK, CK, "alice");

msg = sendMessage(stateAlice, "hello bob");
â†’ send over server

 # Bob side
stateBob = initDoubleRatchet(RK, CK, "bob");

text = receiveMessage(stateBob, msg);
â†’ "hello bob"


âœ” Same MK
âœ” Same CK progression
âœ” Server sees only ciphertext
âœ” No keys shared directly
# Correct X3DH â€” Alice side (VERY IMPORTANT)
Alice has:

I_A â†’ Alice identity key pair

E_A â†’ Alice ephemeral key pair

Alice fetched from Bob:

I_B.publicKey

S_B.publicKey (signed prekey)

O_B.publicKey (one-time prekey, optional)
# Skipped message handling:
// state = {
  RK,
  CKs,
  CKr,

  DHs,
  DHr,

  Ns,
  Nr,

  skippedKeys: new Map() // ğŸ‘ˆ REQUIRED # key = `${dhPubBase64}:${msgNumber}`
value = MK (Uint8Array)

};
//
# Now the 3 cases (THIS IS THE CORE)
âœ… Case 1: header.n === state.Nr (NORMAL case)

Example:

header.n = 2
state.Nr = 2


Meaning:

â€œThis is exactly the message I was expecting.â€

What Bob does:

Derive one MK

Decrypt

Increment Nr

derive MK
decrypt
Nr++


âœ… No skipping
âœ… No storage
âœ… Most common case

â© Case 2: header.n > state.Nr (OUT-OF-ORDER / FUTURE message)

Example:

header.n = 4
state.Nr = 2


Meaning:

â€œAlice jumped ahead â€” messages 2 and 3 are missing.â€

What Bob must do:

Derive keys for messages 2 and 3

Store them as skipped keys

Then derive key for message 4

Visual:

Missing: 2, 3
Current:        4

Code logic:
skipMessageKeys(state, header.n);
derive MK for header.n
decrypt
Nr++


âœ… Enables out-of-order delivery
âœ… Prevents key loss
âœ… REQUIRED by Signal

âª Case 3: header.n < state.Nr (LATE / DUPLICATE message)

Example:

header.n = 1
state.Nr = 3


Meaning:

â€œThis message belongs to the past.â€

Two possibilities:
a Legit late message

Bob previously stored the MK in MKSKIPPED

He decrypts using stored key

if (MKSKIPPED.has(keyId)) decrypt

b Replay / attack / duplicate

No key stored

Reject message

throw Error


âŒ Never derive keys backwards
âŒ Never reuse CK
# imp :
// app startup
const storageKey = await loadStorageKeyFromPassword(); // Argon2 / pwhash
let state = loadRatchetState(storageKey);

if (!state) {
  // only if NO previous session exists
  state = await initDoubleRatchetBob(RK, E_A_pub);
  persistRatchetState(state, storageKey);
}
# What â€œpersist full ratchet stateâ€ really means

If the app:

crashes

reloads

device restarts

ğŸ‘‰ you must be able to resume decryption and encryption
ğŸ‘‰ without re-running X3DH
ğŸ‘‰ without losing skipped keys

So we must persist ALL cryptographic state that affects future keys.
# Crash scenario (proof this works)
Scenario

Bob receives n=2

Skipped keys n=0,1 stored

App crashes

App restarts

Alice sends n=0

What happens

State loads

skippedKeys restored

MK(0) exists

Message decrypts

âœ… No data loss
âœ… No rekeying
âœ… No broken chain